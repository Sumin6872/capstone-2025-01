# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `liquid` gem.
# Please instead update this file by running `bin/tapioca gem liquid`.


# source://liquid//lib/liquid/extensions.rb#18
class Array
  include ::Enumerable

  # source://liquid//lib/liquid/extensions.rb#19
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#54
class Date
  include ::Comparable

  # source://liquid//lib/liquid/extensions.rb#55
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#48
class DateTime < ::Date
  # source://liquid//lib/liquid/extensions.rb#49
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#66
class FalseClass
  # source://liquid//lib/liquid/extensions.rb#67
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#24
class Hash
  include ::Enumerable

  # source://liquid//lib/liquid/extensions.rb#25
  def to_liquid; end
end

# source://liquid//lib/liquid.rb#26
module Liquid; end

# source://liquid//lib/liquid.rb#43
Liquid::AnyStartingTag = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/errors.rb#43
class Liquid::ArgumentError < ::Liquid::Error; end

# source://liquid//lib/liquid.rb#28
Liquid::ArgumentSeparator = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid/tags/assign.rb#16
class Liquid::Assign < ::Liquid::Tag
  # @return [Assign] a new instance of Assign
  #
  # source://liquid//lib/liquid/tags/assign.rb#26
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/assign.rb#43
  def blank?; end

  # Returns the value of attribute from.
  #
  # source://liquid//lib/liquid/tags/assign.rb#24
  def from; end

  # source://liquid//lib/liquid/tags/assign.rb#36
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute to.
  #
  # source://liquid//lib/liquid/tags/assign.rb#24
  def to; end

  private

  # source://liquid//lib/liquid/tags/assign.rb#49
  def assign_score_of(val); end

  class << self
    # @api private
    # @raise [Liquid::SyntaxError]
    #
    # source://liquid//lib/liquid/tags/assign.rb#20
    def raise_syntax_error(parse_context); end
  end
end

# source://liquid//lib/liquid/tags/assign.rb#69
class Liquid::Assign::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/assign.rb#70
  def children; end
end

# source://liquid//lib/liquid/tags/assign.rb#17
Liquid::Assign::Syntax = T.let(T.unsafe(nil), Regexp)

# A Liquid file system is a way to let your templates retrieve other templates for use with the include tag.
#
# You can implement subclasses that retrieve templates from the database, from the file system using a different
# path structure, you can provide them as hard-coded inline strings, or any manner that you see fit.
#
# You can add additional instance variables, arguments, or methods as needed.
#
# Example:
#
#   Liquid::Template.file_system = Liquid::LocalFileSystem.new(template_path)
#   liquid = Liquid::Template.parse(template)
#
# This will parse the template with a LocalFileSystem implementation rooted at 'template_path'.
#
# source://liquid//lib/liquid/file_system.rb#17
class Liquid::BlankFileSystem
  # Called by Liquid to retrieve a template file
  #
  # @raise [FileSystemError]
  #
  # source://liquid//lib/liquid/file_system.rb#19
  def read_template_file(_template_path); end
end

# source://liquid//lib/liquid/block.rb#4
class Liquid::Block < ::Liquid::Tag
  # @return [Block] a new instance of Block
  #
  # source://liquid//lib/liquid/block.rb#7
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/block.rb#24
  def blank?; end

  # source://liquid//lib/liquid/block.rb#63
  def block_delimiter; end

  # source://liquid//lib/liquid/block.rb#59
  def block_name; end

  # source://liquid//lib/liquid/block.rb#28
  def nodelist; end

  # source://liquid//lib/liquid/block.rb#12
  def parse(tokens); end

  # @raise [SyntaxError]
  #
  # source://liquid//lib/liquid/block.rb#55
  def raise_tag_never_closed(block_name); end

  # For backwards compatibility
  #
  # source://liquid//lib/liquid/block.rb#20
  def render(context); end

  # source://liquid//lib/liquid/block.rb#32
  def unknown_tag(tag_name, _markup, _tokenizer); end

  private

  # @api public
  #
  # source://liquid//lib/liquid/block.rb#70
  def new_body; end

  # @api public
  #
  # source://liquid//lib/liquid/block.rb#75
  def parse_body(body, tokens); end

  class << self
    # @api private
    #
    # source://liquid//lib/liquid/block.rb#37
    def raise_unknown_tag(tag, block_name, block_delimiter, parse_context); end
  end
end

# source://liquid//lib/liquid/block.rb#5
Liquid::Block::MAX_DEPTH = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/block_body.rb#6
class Liquid::BlockBody
  # @return [BlockBody] a new instance of BlockBody
  #
  # source://liquid//lib/liquid/block_body.rb#17
  def initialize; end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/block_body.rb#190
  def blank?; end

  # source://liquid//lib/liquid/block_body.rb#34
  def freeze; end

  # Returns the value of attribute nodelist.
  #
  # source://liquid//lib/liquid/block_body.rb#15
  def nodelist; end

  # @raise [FrozenError]
  #
  # source://liquid//lib/liquid/block_body.rb#22
  def parse(tokenizer, parse_context, &block); end

  # Remove blank strings in the block body for a control flow tag (e.g. `if`, `for`, `case`, `unless`)
  # with a blank body.
  #
  # For example, in a conditional assignment like the following
  #
  # ```
  # {% if size > max_size %}
  #   {% assign size = max_size %}
  # {% endif %}
  # ```
  #
  # we assume the intention wasn't to output the blank spaces in the `if` tag's block body, so this method
  # will remove them to reduce the render output size.
  #
  # Note that it is now preferred to use the `liquid` tag for this use case.
  #
  # source://liquid//lib/liquid/block_body.rb#209
  def remove_blank_strings; end

  # source://liquid//lib/liquid/block_body.rb#214
  def render(context); end

  # source://liquid//lib/liquid/block_body.rb#218
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/block_body.rb#176
  def whitespace_handler(token, parse_context); end

  private

  # source://liquid//lib/liquid/block_body.rb#248
  def create_variable(token, parse_context); end

  # source://liquid//lib/liquid/block_body.rb#119
  def handle_invalid_tag_token(token, parse_context); end

  # @yield [nil, nil]
  #
  # source://liquid//lib/liquid/block_body.rb#127
  def parse_for_document(tokenizer, parse_context, &block); end

  # @yield [nil, nil]
  #
  # source://liquid//lib/liquid/block_body.rb#39
  def parse_for_liquid_tag(tokenizer, parse_context); end

  # source://liquid//lib/liquid/block_body.rb#108
  def parse_liquid_tag(markup, parse_context); end

  # @deprecated Use {.raise_missing_tag_terminator} instead
  #
  # source://liquid//lib/liquid/block_body.rb#264
  def raise_missing_tag_terminator(token, parse_context); end

  # @deprecated Use {.raise_missing_variable_terminator} instead
  #
  # source://liquid//lib/liquid/block_body.rb#269
  def raise_missing_variable_terminator(token, parse_context); end

  # source://liquid//lib/liquid/block_body.rb#244
  def render_node(context, output, node); end

  class << self
    # @api private
    # @raise [SyntaxError]
    #
    # source://liquid//lib/liquid/block_body.rb#76
    def raise_missing_tag_terminator(token, parse_context); end

    # @api private
    # @raise [SyntaxError]
    #
    # source://liquid//lib/liquid/block_body.rb#81
    def raise_missing_variable_terminator(token, parse_context); end

    # @api private
    #
    # source://liquid//lib/liquid/block_body.rb#86
    def render_node(context, output, node); end

    # @api private
    #
    # source://liquid//lib/liquid/block_body.rb#94
    def rescue_render_node(context, output, line_number, exc, blank_tag); end

    # @api private
    #
    # source://liquid//lib/liquid/block_body.rb#71
    def unknown_tag_in_liquid_tag(tag, parse_context); end
  end
end

# source://liquid//lib/liquid/block_body.rb#10
Liquid::BlockBody::ContentOfVariable = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/block_body.rb#8
Liquid::BlockBody::FullToken = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/block_body.rb#9
Liquid::BlockBody::FullTokenPossiblyInvalid = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/block_body.rb#7
Liquid::BlockBody::LiquidTagToken = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/block_body.rb#12
Liquid::BlockBody::TAGSTART = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid/block_body.rb#13
Liquid::BlockBody::VARSTART = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid/block_body.rb#11
Liquid::BlockBody::WhitespaceOrNothing = T.let(T.unsafe(nil), Regexp)

# Break tag to be used to break out of a for loop.
#
# == Basic Usage:
#    {% for item in collection %}
#      {% if item.condition %}
#        {% break %}
#      {% endif %}
#    {% endfor %}
#
# source://liquid//lib/liquid/tags/break.rb#21
class Liquid::Break < ::Liquid::Tag
  # source://liquid//lib/liquid/tags/break.rb#24
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/tags/break.rb#22
Liquid::Break::INTERRUPT = T.let(T.unsafe(nil), Liquid::BreakInterrupt)

# Interrupt that is thrown whenever a {% break %} is called.
#
# source://liquid//lib/liquid/interrupts.rb#14
class Liquid::BreakInterrupt < ::Liquid::Interrupt; end

# source://liquid//lib/liquid/tags/capture.rb#18
class Liquid::Capture < ::Liquid::Block
  # @return [Capture] a new instance of Capture
  #
  # source://liquid//lib/liquid/tags/capture.rb#21
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/capture.rb#38
  def blank?; end

  # source://liquid//lib/liquid/tags/capture.rb#30
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/tags/capture.rb#19
Liquid::Capture::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/case.rb#25
class Liquid::Case < ::Liquid::Block
  # @return [Case] a new instance of Case
  #
  # source://liquid//lib/liquid/tags/case.rb#31
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute blocks.
  #
  # source://liquid//lib/liquid/tags/case.rb#29
  def blocks; end

  # Returns the value of attribute left.
  #
  # source://liquid//lib/liquid/tags/case.rb#29
  def left; end

  # source://liquid//lib/liquid/tags/case.rb#55
  def nodelist; end

  # source://liquid//lib/liquid/tags/case.rb#42
  def parse(tokens); end

  # source://liquid//lib/liquid/tags/case.rb#70
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/tags/case.rb#59
  def unknown_tag(tag, markup, tokens); end

  private

  # source://liquid//lib/liquid/tags/case.rb#110
  def record_else_condition(markup); end

  # source://liquid//lib/liquid/tags/case.rb#94
  def record_when_condition(markup); end
end

# source://liquid//lib/liquid/tags/case.rb#120
class Liquid::Case::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/case.rb#121
  def children; end
end

# source://liquid//lib/liquid/tags/case.rb#26
Liquid::Case::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/case.rb#27
Liquid::Case::WhenSyntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/comment.rb#17
class Liquid::Comment < ::Liquid::Block
  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/comment.rb#25
  def blank?; end

  # source://liquid//lib/liquid/tags/comment.rb#18
  def render_to_output_buffer(_context, output); end

  # source://liquid//lib/liquid/tags/comment.rb#22
  def unknown_tag(_tag, _markup, _tokens); end

  private

  # source://liquid//lib/liquid/tags/comment.rb#31
  def parse_body(body, tokenizer); end

  # source://liquid//lib/liquid/tags/comment.rb#80
  def parse_raw_tag_body(tokenizer); end
end

# Container for liquid nodes which conveniently wraps decision making logic
#
# Example:
#
#   c = Condition.new(1, '==', 1)
#   c.evaluate #=> true
#
# source://liquid//lib/liquid/condition.rb#11
class Liquid::Condition
  # @return [Condition] a new instance of Condition
  #
  # source://liquid//lib/liquid/condition.rb#58
  def initialize(left = T.unsafe(nil), operator = T.unsafe(nil), right = T.unsafe(nil)); end

  # source://liquid//lib/liquid/condition.rb#91
  def and(condition); end

  # source://liquid//lib/liquid/condition.rb#96
  def attach(attachment); end

  # Returns the value of attribute attachment.
  #
  # source://liquid//lib/liquid/condition.rb#55
  def attachment; end

  # Returns the value of attribute child_condition.
  #
  # source://liquid//lib/liquid/condition.rb#55
  def child_condition; end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/condition.rb#100
  def else?; end

  # source://liquid//lib/liquid/condition.rb#67
  def evaluate(context = T.unsafe(nil)); end

  # source://liquid//lib/liquid/condition.rb#104
  def inspect; end

  # Returns the value of attribute left.
  #
  # source://liquid//lib/liquid/condition.rb#56
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  #
  # source://liquid//lib/liquid/condition.rb#56
  def left=(_arg0); end

  # Returns the value of attribute operator.
  #
  # source://liquid//lib/liquid/condition.rb#56
  def operator; end

  # Sets the attribute operator
  #
  # @param value the value to set the attribute operator to.
  #
  # source://liquid//lib/liquid/condition.rb#56
  def operator=(_arg0); end

  # source://liquid//lib/liquid/condition.rb#86
  def or(condition); end

  # Returns the value of attribute right.
  #
  # source://liquid//lib/liquid/condition.rb#56
  def right; end

  # Sets the attribute right
  #
  # @param value the value to set the attribute right to.
  #
  # source://liquid//lib/liquid/condition.rb#56
  def right=(_arg0); end

  protected

  # Returns the value of attribute child_relation.
  #
  # source://liquid//lib/liquid/condition.rb#110
  def child_relation; end

  private

  # source://liquid//lib/liquid/condition.rb#156
  def deprecated_default_context; end

  # source://liquid//lib/liquid/condition.rb#114
  def equal_variables(left, right); end

  # source://liquid//lib/liquid/condition.rb#134
  def interpret_condition(left, right, op, context); end

  class << self
    # source://liquid//lib/liquid/condition.rb#47
    def operators; end

    # source://liquid//lib/liquid/condition.rb#51
    def parse_expression(parse_context, markup); end
  end
end

# source://liquid//lib/liquid/condition.rb#33
class Liquid::Condition::MethodLiteral
  # @return [MethodLiteral] a new instance of MethodLiteral
  #
  # source://liquid//lib/liquid/condition.rb#36
  def initialize(method_name, to_s); end

  # Returns the value of attribute method_name.
  #
  # source://liquid//lib/liquid/condition.rb#34
  def method_name; end

  # Returns the value of attribute to_s.
  #
  # source://liquid//lib/liquid/condition.rb#34
  def to_s; end
end

# source://liquid//lib/liquid/condition.rb#162
class Liquid::Condition::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/condition.rb#163
  def children; end
end

# source://liquid//lib/liquid/const.rb#4
module Liquid::Const; end

# source://liquid//lib/liquid/const.rb#6
Liquid::Const::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/const.rb#5
Liquid::Const::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Context keeps the variable stack and resolves variables, as well as keywords
#
#   context['variable'] = 'testing'
#   context['variable'] #=> 'testing'
#   context['true']     #=> true
#   context['10.2232']  #=> 10.2232
#
#   context.stack do
#      context['bob'] = 'bobsen'
#   end
#
#   context['bob']  #=> nil  class Context
#
# source://liquid//lib/liquid/context.rb#16
class Liquid::Context
  # @return [Context] a new instance of Context
  # @yield [_self]
  # @yieldparam _self [Liquid::Context] the object that the method was called on
  #
  # source://liquid//lib/liquid/context.rb#25
  def initialize(environments = T.unsafe(nil), outer_scope = T.unsafe(nil), registers = T.unsafe(nil), rethrow_errors = T.unsafe(nil), resource_limits = T.unsafe(nil), static_environments = T.unsafe(nil), environment = T.unsafe(nil)); end

  # Look up variable, either resolve directly after considering the name. We can directly handle
  # Strings, digits, floats and booleans (true,false).
  # If no match is made we lookup the variable in the current scope and
  # later move up to the parent blocks to see if we can resolve the variable somewhere up the tree.
  # Some special keywords return symbols. Those symbols are to be called on the rhs object in expressions
  #
  # Example:
  #   products == empty #=> products.empty?
  #
  # source://liquid//lib/liquid/context.rb#182
  def [](expression); end

  # Only allow String, Numeric, Hash, Array, Proc, Boolean or <tt>Liquid::Drop</tt>
  #
  # source://liquid//lib/liquid/context.rb#170
  def []=(key, value); end

  # Adds filters to this context.
  #
  # Note that this does not register the filters with the main Template object. see <tt>Template.register_filter</tt>
  # for that
  #
  # source://liquid//lib/liquid/context.rb#75
  def add_filters(filters); end

  # source://liquid//lib/liquid/context.rb#81
  def apply_global_filter(obj); end

  # source://liquid//lib/liquid/context.rb#165
  def clear_instance_assigns; end

  # Returns the value of attribute environment.
  #
  # source://liquid//lib/liquid/context.rb#18
  def environment; end

  # Sets the attribute environment
  #
  # @param value the value to set the attribute environment to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def environment=(_arg0); end

  # Returns the value of attribute environments.
  #
  # source://liquid//lib/liquid/context.rb#17
  def environments; end

  # Returns the value of attribute errors.
  #
  # source://liquid//lib/liquid/context.rb#17
  def errors; end

  # source://liquid//lib/liquid/context.rb#190
  def evaluate(object); end

  # Returns the value of attribute exception_renderer.
  #
  # source://liquid//lib/liquid/context.rb#18
  def exception_renderer; end

  # Sets the attribute exception_renderer
  #
  # @param value the value to set the attribute exception_renderer to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def exception_renderer=(_arg0); end

  # Fetches an object starting at the local scope and then moving up the hierachy
  #
  # source://liquid//lib/liquid/context.rb#195
  def find_variable(key, raise_on_not_found: T.unsafe(nil)); end

  # Returns the value of attribute global_filter.
  #
  # source://liquid//lib/liquid/context.rb#18
  def global_filter; end

  # Sets the attribute global_filter
  #
  # @param value the value to set the attribute global_filter to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def global_filter=(_arg0); end

  # source://liquid//lib/liquid/context.rb#100
  def handle_error(e, line_number = T.unsafe(nil)); end

  # are there any not handled interrupts?
  #
  # @return [Boolean]
  #
  # source://liquid//lib/liquid/context.rb#86
  def interrupt?; end

  # source://liquid//lib/liquid/context.rb#108
  def invoke(method, *args); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/context.rb#186
  def key?(key); end

  # source://liquid//lib/liquid/context.rb#216
  def lookup_and_evaluate(obj, key, raise_on_not_found: T.unsafe(nil)); end

  # Merge a hash of variables in the current local scope
  #
  # source://liquid//lib/liquid/context.rb#119
  def merge(new_scopes); end

  # Creates a new context inheriting resource limits, filters, environment etc.,
  # but with an isolated scope.
  #
  # source://liquid//lib/liquid/context.rb#146
  def new_isolated_subcontext; end

  # Returns the value of attribute partial.
  #
  # source://liquid//lib/liquid/context.rb#18
  def partial; end

  # Sets the attribute partial
  #
  # @param value the value to set the attribute partial to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def partial=(_arg0); end

  # Pop from the stack. use <tt>Context#stack</tt> instead
  #
  # @raise [ContextError]
  #
  # source://liquid//lib/liquid/context.rb#124
  def pop; end

  # pop an interrupt from the stack
  #
  # source://liquid//lib/liquid/context.rb#96
  def pop_interrupt; end

  # Push new local scope on the stack. use <tt>Context#stack</tt> instead
  #
  # source://liquid//lib/liquid/context.rb#113
  def push(new_scope = T.unsafe(nil)); end

  # push an interrupt to the stack. this interrupt is considered not handled.
  #
  # source://liquid//lib/liquid/context.rb#91
  def push_interrupt(e); end

  # Returns the value of attribute registers.
  #
  # source://liquid//lib/liquid/context.rb#17
  def registers; end

  # Returns the value of attribute resource_limits.
  #
  # source://liquid//lib/liquid/context.rb#17
  def resource_limits; end

  # Returns the value of attribute scopes.
  #
  # source://liquid//lib/liquid/context.rb#17
  def scopes; end

  # Pushes a new local scope on the stack, pops it at the end of the block
  #
  # Example:
  #   context.stack do
  #      context['var'] = 'hi'
  #   end
  #
  #   context['var']  #=> nil
  #
  # source://liquid//lib/liquid/context.rb#137
  def stack(new_scope = T.unsafe(nil)); end

  # Returns the value of attribute static_environments.
  #
  # source://liquid//lib/liquid/context.rb#17
  def static_environments; end

  # Returns the value of attribute static_registers.
  #
  # source://liquid//lib/liquid/context.rb#17
  def static_registers; end

  # source://liquid//lib/liquid/context.rb#67
  def strainer; end

  # Returns the value of attribute strict_filters.
  #
  # source://liquid//lib/liquid/context.rb#18
  def strict_filters; end

  # Sets the attribute strict_filters
  #
  # @param value the value to set the attribute strict_filters to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def strict_filters=(_arg0); end

  # Returns the value of attribute strict_variables.
  #
  # source://liquid//lib/liquid/context.rb#18
  def strict_variables; end

  # Sets the attribute strict_variables
  #
  # @param value the value to set the attribute strict_variables to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def strict_variables=(_arg0); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/context.rb#241
  def tag_disabled?(tag_name); end

  # Returns the value of attribute template_name.
  #
  # source://liquid//lib/liquid/context.rb#18
  def template_name; end

  # Sets the attribute template_name
  #
  # @param value the value to set the attribute template_name to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def template_name=(_arg0); end

  # source://liquid//lib/liquid/context.rb#63
  def warnings; end

  # source://liquid//lib/liquid/context.rb#230
  def with_disabled_tags(tag_names); end

  protected

  # Sets the attribute base_scope_depth
  #
  # @param value the value to set the attribute base_scope_depth to.
  #
  # source://liquid//lib/liquid/context.rb#247
  def base_scope_depth=(_arg0); end

  # Sets the attribute disabled_tags
  #
  # @param value the value to set the attribute disabled_tags to.
  #
  # source://liquid//lib/liquid/context.rb#247
  def disabled_tags=(_arg0); end

  # Sets the attribute errors
  #
  # @param value the value to set the attribute errors to.
  #
  # source://liquid//lib/liquid/context.rb#247
  def errors=(_arg0); end

  # Sets the attribute filters
  #
  # @param value the value to set the attribute filters to.
  #
  # source://liquid//lib/liquid/context.rb#247
  def filters=(_arg0); end

  # Sets the attribute strainer
  #
  # @param value the value to set the attribute strainer to.
  #
  # source://liquid//lib/liquid/context.rb#247
  def strainer=(_arg0); end

  # Sets the attribute warnings
  #
  # @param value the value to set the attribute warnings to.
  #
  # source://liquid//lib/liquid/context.rb#247
  def warnings=(_arg0); end

  private

  # Returns the value of attribute base_scope_depth.
  #
  # source://liquid//lib/liquid/context.rb#251
  def base_scope_depth; end

  # @raise [StackLevelError]
  #
  # source://liquid//lib/liquid/context.rb#269
  def check_overflow; end

  # source://liquid//lib/liquid/context.rb#277
  def internal_error; end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/context.rb#273
  def overflow?; end

  # source://liquid//lib/liquid/context.rb#284
  def squash_instance_assigns_with_environments; end

  # source://liquid//lib/liquid/context.rb#253
  def try_variable_find_in_environments(key, raise_on_not_found:); end

  class << self
    # source://liquid//lib/liquid/context.rb#21
    def build(environment: T.unsafe(nil), environments: T.unsafe(nil), outer_scope: T.unsafe(nil), registers: T.unsafe(nil), rethrow_errors: T.unsafe(nil), resource_limits: T.unsafe(nil), static_environments: T.unsafe(nil), &block); end
  end
end

# source://liquid//lib/liquid/errors.rb#44
class Liquid::ContextError < ::Liquid::Error; end

# source://liquid//lib/liquid/tags/continue.rb#12
class Liquid::Continue < ::Liquid::Tag
  # source://liquid//lib/liquid/tags/continue.rb#15
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/tags/continue.rb#13
Liquid::Continue::INTERRUPT = T.let(T.unsafe(nil), Liquid::ContinueInterrupt)

# Interrupt that is thrown whenever a {% continue %} is called.
#
# source://liquid//lib/liquid/interrupts.rb#17
class Liquid::ContinueInterrupt < ::Liquid::Interrupt; end

# source://liquid//lib/liquid/tags/cycle.rb#17
class Liquid::Cycle < ::Liquid::Tag
  # @return [Cycle] a new instance of Cycle
  #
  # source://liquid//lib/liquid/tags/cycle.rb#23
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/cycle.rb#39
  def named?; end

  # source://liquid//lib/liquid/tags/cycle.rb#43
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute variables.
  #
  # source://liquid//lib/liquid/tags/cycle.rb#21
  def variables; end

  private

  # source://liquid//lib/liquid/tags/cycle.rb#68
  def variables_from_string(markup); end
end

# source://liquid//lib/liquid/tags/cycle.rb#19
Liquid::Cycle::NamedSyntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/cycle.rb#81
class Liquid::Cycle::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/cycle.rb#82
  def children; end
end

# source://liquid//lib/liquid/tags/cycle.rb#18
Liquid::Cycle::SimpleSyntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/decrement.rb#21
class Liquid::Decrement < ::Liquid::Tag
  # @return [Decrement] a new instance of Decrement
  #
  # source://liquid//lib/liquid/tags/decrement.rb#24
  def initialize(tag_name, markup, options); end

  # source://liquid//lib/liquid/tags/decrement.rb#29
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute variable_name.
  #
  # source://liquid//lib/liquid/tags/decrement.rb#22
  def variable_name; end
end

# source://liquid//lib/liquid/deprecations.rb#6
class Liquid::Deprecations
  class << self
    # source://liquid//lib/liquid/deprecations.rb#12
    def warn(name, alternative); end

    # Returns the value of attribute warned.
    #
    # source://liquid//lib/liquid/deprecations.rb#8
    def warned; end

    # Sets the attribute warned
    #
    # @param value the value to set the attribute warned to.
    #
    # source://liquid//lib/liquid/deprecations.rb#8
    def warned=(_arg0); end
  end
end

# source://liquid//lib/liquid/errors.rb#56
class Liquid::DisabledError < ::Liquid::Error; end

# source://liquid//lib/liquid/tags/doc.rb#31
class Liquid::Doc < ::Liquid::Block
  # @return [Doc] a new instance of Doc
  #
  # source://liquid//lib/liquid/tags/doc.rb#34
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/doc.rb#58
  def blank?; end

  # source://liquid//lib/liquid/tags/doc.rb#62
  def nodelist; end

  # source://liquid//lib/liquid/tags/doc.rb#39
  def parse(tokens); end

  # source://liquid//lib/liquid/tags/doc.rb#54
  def render_to_output_buffer(_context, output); end

  private

  # source://liquid//lib/liquid/tags/doc.rb#68
  def ensure_valid_markup(tag_name, markup, parse_context); end

  # @raise [SyntaxError]
  #
  # source://liquid//lib/liquid/tags/doc.rb#74
  def raise_nested_doc_error; end
end

# source://liquid//lib/liquid/tags/doc.rb#32
Liquid::Doc::NO_UNEXPECTED_ARGS = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/document.rb#4
class Liquid::Document
  # @return [Document] a new instance of Document
  #
  # source://liquid//lib/liquid/document.rb#13
  def initialize(parse_context); end

  # Returns the value of attribute body.
  #
  # source://liquid//lib/liquid/document.rb#11
  def body; end

  # source://liquid//lib/liquid/document.rb#18
  def nodelist; end

  # source://liquid//lib/liquid/document.rb#22
  def parse(tokenizer, parse_context); end

  # Returns the value of attribute parse_context.
  #
  # source://liquid//lib/liquid/document.rb#11
  def parse_context; end

  # source://liquid//lib/liquid/document.rb#44
  def render(context); end

  # source://liquid//lib/liquid/document.rb#40
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/document.rb#31
  def unknown_tag(tag, _markup, _tokenizer); end

  private

  # source://liquid//lib/liquid/document.rb#50
  def new_body; end

  # source://liquid//lib/liquid/document.rb#54
  def parse_body(tokenizer); end

  class << self
    # source://liquid//lib/liquid/document.rb#5
    def parse(tokens, parse_context); end
  end
end

# A drop in liquid is a class which allows you to export DOM like things to liquid.
# Methods of drops are callable.
# The main use for liquid drops is to implement lazy loaded objects.
# If you would like to make data available to the web designers which you don't want loaded unless needed then
# a drop is a great way to do that.
#
# Example:
#
#   class ProductDrop < Liquid::Drop
#     def top_sales
#       Shop.current.products.find(:all, :order => 'sales', :limit => 10 )
#     end
#   end
#
#   tmpl = Liquid::Template.parse( ' {% for product in product.top_sales %} {{ product.name }} {%endfor%} '  )
#   tmpl.render('product' => ProductDrop.new ) # will invoke top_sales query.
#
# Your drop can either implement the methods sans any parameters
# or implement the liquid_method_missing(name) method which is a catch all.
#
# source://liquid//lib/liquid/drop.rb#25
class Liquid::Drop
  # @return [Drop] a new instance of Drop
  #
  # source://liquid//lib/liquid/drop.rb#28
  def initialize; end

  # called by liquid to invoke a drop
  #
  # source://liquid//lib/liquid/drop.rb#39
  def [](method_or_key); end

  # Sets the attribute context
  #
  # @param value the value to set the attribute context to.
  #
  # source://liquid//lib/liquid/drop.rb#26
  def context=(_arg0); end

  # source://liquid//lib/liquid/drop.rb#51
  def inspect; end

  # called by liquid to invoke a drop
  #
  # source://liquid//lib/liquid/drop.rb#39
  def invoke_drop(method_or_key); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/drop.rb#47
  def key?(_name); end

  # Catch all for the method
  #
  # @raise [Liquid::UndefinedDropMethod]
  #
  # source://liquid//lib/liquid/drop.rb#33
  def liquid_method_missing(method); end

  # source://liquid//lib/liquid/drop.rb#55
  def to_liquid; end

  # source://liquid//lib/liquid/drop.rb#59
  def to_s; end

  class << self
    # Check for method existence without invoking respond_to?, which creates symbols
    #
    # @return [Boolean]
    #
    # source://liquid//lib/liquid/drop.rb#66
    def invokable?(method_name); end

    # source://liquid//lib/liquid/drop.rb#70
    def invokable_methods; end
  end
end

# source://liquid//lib/liquid/tags/echo.rb#21
class Liquid::Echo < ::Liquid::Tag
  # @return [Echo] a new instance of Echo
  #
  # source://liquid//lib/liquid/tags/echo.rb#24
  def initialize(tag_name, markup, parse_context); end

  # source://liquid//lib/liquid/tags/echo.rb#29
  def render(context); end

  # Returns the value of attribute variable.
  #
  # source://liquid//lib/liquid/tags/echo.rb#22
  def variable; end
end

# source://liquid//lib/liquid/tags/echo.rb#33
class Liquid::Echo::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/echo.rb#34
  def children; end
end

# source://liquid//lib/liquid/condition.rb#174
class Liquid::ElseCondition < ::Liquid::Condition
  # @return [Boolean]
  #
  # source://liquid//lib/liquid/condition.rb#175
  def else?; end

  # source://liquid//lib/liquid/condition.rb#179
  def evaluate(_context); end
end

# The Environment is the container for all configuration options of Liquid, such as
# the registered tags, filters, and the default error mode.
#
# source://liquid//lib/liquid/environment.rb#6
class Liquid::Environment
  # Initializes a new environment instance.
  #
  # @api private
  # @return [Environment] a new instance of Environment
  #
  # source://liquid//lib/liquid/environment.rb#76
  def initialize; end

  # Creates a new strainer instance with the given filters, caching the result
  # for faster lookup.
  #
  # @param context [Liquid::Context] The context that the strainer will be
  #   used in.
  # @param filters [Array<Module>] The filters that the strainer will have
  #   access to.
  # @return [Liquid::Strainer] The new strainer instance.
  #
  # source://liquid//lib/liquid/environment.rb#124
  def create_strainer(context, filters = T.unsafe(nil)); end

  # The default resource limits that are used to limit the resources that a
  # template can consume.
  #
  # source://liquid//lib/liquid/environment.rb#27
  def default_resource_limits; end

  # The default resource limits that are used to limit the resources that a
  # template can consume.
  #
  # source://liquid//lib/liquid/environment.rb#27
  def default_resource_limits=(_arg0); end

  # The default error mode for all templates. This can be overridden on a
  # per-template basis.
  #
  # source://liquid//lib/liquid/environment.rb#9
  def error_mode; end

  # The default error mode for all templates. This can be overridden on a
  # per-template basis.
  #
  # source://liquid//lib/liquid/environment.rb#9
  def error_mode=(_arg0); end

  # The exception renderer that is used to render exceptions that are raised
  # when rendering a template
  #
  # source://liquid//lib/liquid/environment.rb#20
  def exception_renderer; end

  # The exception renderer that is used to render exceptions that are raised
  # when rendering a template
  #
  # source://liquid//lib/liquid/environment.rb#20
  def exception_renderer=(_arg0); end

  # The default file system that is used to load templates from.
  #
  # source://liquid//lib/liquid/environment.rb#23
  def file_system; end

  # The default file system that is used to load templates from.
  #
  # source://liquid//lib/liquid/environment.rb#23
  def file_system=(_arg0); end

  # Returns the names of all the filter methods that are available to use in
  # the strainer template.
  #
  # @return [Array<String>] The names of all the filter methods.
  #
  # source://liquid//lib/liquid/environment.rb#140
  def filter_method_names; end

  # source://liquid//lib/liquid/environment.rb#152
  def freeze; end

  # Registers a new filter with the environment.
  #
  # @param filter [Module] The module that contains the filter methods.
  # @return [void]
  #
  # source://liquid//lib/liquid/environment.rb#101
  def register_filter(filter); end

  # Registers multiple filters with this environment.
  #
  # @param filters [Array<Module>] The modules that contain the filter methods.
  # @return [self]
  #
  # source://liquid//lib/liquid/environment.rb#110
  def register_filters(filters); end

  # Registers a new tag with the environment.
  #
  # @param name [String] The name of the tag.
  # @param klass [Liquid::Tag] The class that implements the tag.
  # @return [void]
  #
  # source://liquid//lib/liquid/environment.rb#93
  def register_tag(name, klass); end

  # The strainer template which is used to store filters that are available to
  # use in templates.
  #
  # source://liquid//lib/liquid/environment.rb#16
  def strainer_template; end

  # The strainer template which is used to store filters that are available to
  # use in templates.
  #
  # source://liquid//lib/liquid/environment.rb#16
  def strainer_template=(_arg0); end

  # Returns the tag class for the given tag name.
  #
  # @param name [String] The name of the tag.
  # @return [Liquid::Tag] The tag class.
  #
  # source://liquid//lib/liquid/environment.rb#148
  def tag_for_name(name); end

  # The tags that are available to use in the template.
  #
  # source://liquid//lib/liquid/environment.rb#12
  def tags; end

  # The tags that are available to use in the template.
  #
  # source://liquid//lib/liquid/environment.rb#12
  def tags=(_arg0); end

  class << self
    # Creates a new environment instance.
    #
    # @param tags [Hash] The tags that are available to use in
    #   the template.
    # @param file_system The default file system that is used
    #   to load templates from.
    # @param error_mode [Symbol] The default error mode for all templates
    #   (either :strict, :warn, or :lax).
    # @param exception_renderer [Proc] The exception renderer that is used to
    #   render exceptions.
    # @return [Environment] The new environment instance.
    # @yieldparam environment [Environment] The environment instance that is being built.
    #
    # source://liquid//lib/liquid/environment.rb#42
    def build(tags: T.unsafe(nil), file_system: T.unsafe(nil), error_mode: T.unsafe(nil), exception_renderer: T.unsafe(nil)); end

    # Sets the default environment instance for the duration of the block
    #
    # @param environment [Environment] The environment instance to use as the default for the
    #   duration of the block.
    # @return [Object] The return value of the block.
    # @yield
    #
    # source://liquid//lib/liquid/environment.rb#65
    def dangerously_override(environment); end

    # Returns the default environment instance.
    #
    # @return [Environment] The default environment instance.
    #
    # source://liquid//lib/liquid/environment.rb#55
    def default; end
  end
end

# source://liquid//lib/liquid/errors.rb#4
class Liquid::Error < ::StandardError
  # Returns the value of attribute line_number.
  #
  # source://liquid//lib/liquid/errors.rb#5
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  #
  # source://liquid//lib/liquid/errors.rb#5
  def line_number=(_arg0); end

  # Returns the value of attribute markup_context.
  #
  # source://liquid//lib/liquid/errors.rb#7
  def markup_context; end

  # Sets the attribute markup_context
  #
  # @param value the value to set the attribute markup_context to.
  #
  # source://liquid//lib/liquid/errors.rb#7
  def markup_context=(_arg0); end

  # Returns the value of attribute template_name.
  #
  # source://liquid//lib/liquid/errors.rb#6
  def template_name; end

  # Sets the attribute template_name
  #
  # @param value the value to set the attribute template_name to.
  #
  # source://liquid//lib/liquid/errors.rb#6
  def template_name=(_arg0); end

  # source://liquid//lib/liquid/errors.rb#9
  def to_s(with_prefix = T.unsafe(nil)); end

  private

  # source://liquid//lib/liquid/errors.rb#24
  def message_prefix; end
end

# source://liquid//lib/liquid/expression.rb#4
class Liquid::Expression
  class << self
    # source://liquid//lib/liquid/expression.rb#53
    def inner_parse(markup, ss, cache); end

    # source://liquid//lib/liquid/expression.rb#31
    def parse(markup, ss = T.unsafe(nil), cache = T.unsafe(nil)); end

    # source://liquid//lib/liquid/expression.rb#70
    def parse_number(markup, ss); end
  end
end

# source://liquid//lib/liquid/expression.rb#22
Liquid::Expression::DASH = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/expression.rb#19
Liquid::Expression::DOT = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/expression.rb#28
Liquid::Expression::FLOAT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/expression.rb#27
Liquid::Expression::INTEGER_REGEX = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/expression.rb#5
Liquid::Expression::LITERALS = T.let(T.unsafe(nil), Hash)

# source://liquid//lib/liquid/expression.rb#21
Liquid::Expression::NINE = T.let(T.unsafe(nil), Integer)

# Use an atomic group (?>...) to avoid pathological backtracing from
# malicious input as described in https://github.com/Shopify/liquid/issues/1357
#
# source://liquid//lib/liquid/expression.rb#26
Liquid::Expression::RANGES_REGEX = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/expression.rb#20
Liquid::Expression::ZERO = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/errors.rb#45
class Liquid::FileSystemError < ::Liquid::Error; end

# source://liquid//lib/liquid.rb#29
Liquid::FilterArgumentSeparator = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid.rb#27
Liquid::FilterSeparator = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/errors.rb#51
class Liquid::FloatDomainError < ::Liquid::Error; end

# source://liquid//lib/liquid/tags/for.rb#27
class Liquid::For < ::Liquid::Block
  # @return [For] a new instance of For
  #
  # source://liquid//lib/liquid/tags/for.rb#32
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute collection_name.
  #
  # source://liquid//lib/liquid/tags/for.rb#30
  def collection_name; end

  # Returns the value of attribute from.
  #
  # source://liquid//lib/liquid/tags/for.rb#30
  def from; end

  # Returns the value of attribute limit.
  #
  # source://liquid//lib/liquid/tags/for.rb#30
  def limit; end

  # source://liquid//lib/liquid/tags/for.rb#52
  def nodelist; end

  # source://liquid//lib/liquid/tags/for.rb#40
  def parse(tokens); end

  # source://liquid//lib/liquid/tags/for.rb#61
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/tags/for.rb#56
  def unknown_tag(tag, markup, tokens); end

  # Returns the value of attribute variable_name.
  #
  # source://liquid//lib/liquid/tags/for.rb#30
  def variable_name; end

  protected

  # source://liquid//lib/liquid/tags/for.rb#75
  def lax_parse(markup); end

  # @raise [SyntaxError]
  #
  # source://liquid//lib/liquid/tags/for.rb#90
  def strict_parse(markup); end

  private

  # source://liquid//lib/liquid/tags/for.rb#114
  def collection_segment(context); end

  # source://liquid//lib/liquid/tags/for.rb#190
  def render_else(context, output); end

  # source://liquid//lib/liquid/tags/for.rb#146
  def render_segment(context, output, segment); end

  # source://liquid//lib/liquid/tags/for.rb#177
  def set_attribute(key, expr); end
end

# source://liquid//lib/liquid/tags/for.rb#198
class Liquid::For::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/for.rb#199
  def children; end
end

# source://liquid//lib/liquid/tags/for.rb#28
Liquid::For::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/forloop_drop.rb#9
class Liquid::ForloopDrop < ::Liquid::Drop
  # @return [ForloopDrop] a new instance of ForloopDrop
  #
  # source://liquid//lib/liquid/forloop_drop.rb#10
  def initialize(name, length, parentloop); end

  # source://liquid//lib/liquid/forloop_drop.rb#71
  def first; end

  # source://liquid//lib/liquid/forloop_drop.rb#39
  def index; end

  # source://liquid//lib/liquid/forloop_drop.rb#47
  def index0; end

  # source://liquid//lib/liquid/forloop_drop.rb#79
  def last; end

  # Returns the value of attribute length.
  #
  # source://liquid//lib/liquid/forloop_drop.rb#22
  def length; end

  # Returns the value of attribute name.
  #
  # source://liquid//lib/liquid/forloop_drop.rb#33
  def name; end

  # Returns the value of attribute parentloop.
  #
  # source://liquid//lib/liquid/forloop_drop.rb#31
  def parentloop; end

  # source://liquid//lib/liquid/forloop_drop.rb#55
  def rindex; end

  # source://liquid//lib/liquid/forloop_drop.rb#63
  def rindex0; end

  protected

  # source://liquid//lib/liquid/forloop_drop.rb#85
  def increment!; end
end

# source://liquid//lib/liquid.rb#49
Liquid::HAS_STRING_SCANNER_SCAN_BYTE = T.let(T.unsafe(nil), TrueClass)

# source://liquid//lib/liquid/i18n.rb#6
class Liquid::I18n
  # @return [I18n] a new instance of I18n
  #
  # source://liquid//lib/liquid/i18n.rb#13
  def initialize(path = T.unsafe(nil)); end

  # source://liquid//lib/liquid/i18n.rb#22
  def locale; end

  # Returns the value of attribute path.
  #
  # source://liquid//lib/liquid/i18n.rb#11
  def path; end

  # source://liquid//lib/liquid/i18n.rb#17
  def t(name, vars = T.unsafe(nil)); end

  # source://liquid//lib/liquid/i18n.rb#17
  def translate(name, vars = T.unsafe(nil)); end

  private

  # source://liquid//lib/liquid/i18n.rb#35
  def deep_fetch_translation(name); end

  # source://liquid//lib/liquid/i18n.rb#28
  def interpolate(name, vars); end
end

# source://liquid//lib/liquid/i18n.rb#7
Liquid::I18n::DEFAULT_LOCALE = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid/i18n.rb#9
class Liquid::I18n::TranslationError < ::StandardError; end

# source://liquid//lib/liquid/tags/if.rb#16
class Liquid::If < ::Liquid::Block
  # @return [If] a new instance of If
  #
  # source://liquid//lib/liquid/tags/if.rb#23
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute blocks.
  #
  # source://liquid//lib/liquid/tags/if.rb#21
  def blocks; end

  # source://liquid//lib/liquid/tags/if.rb#29
  def nodelist; end

  # source://liquid//lib/liquid/tags/if.rb#33
  def parse(tokens); end

  # source://liquid//lib/liquid/tags/if.rb#53
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/tags/if.rb#45
  def unknown_tag(tag, markup, tokens); end

  private

  # @raise [SyntaxError]
  #
  # source://liquid//lib/liquid/tags/if.rb#84
  def lax_parse(markup); end

  # source://liquid//lib/liquid/tags/if.rb#111
  def parse_binary_comparisons(p); end

  # source://liquid//lib/liquid/tags/if.rb#122
  def parse_comparison(p); end

  # source://liquid//lib/liquid/tags/if.rb#80
  def parse_expression(markup); end

  # source://liquid//lib/liquid/tags/if.rb#69
  def push_block(tag, markup); end

  # source://liquid//lib/liquid/tags/if.rb#104
  def strict_parse(markup); end
end

# source://liquid//lib/liquid/tags/if.rb#19
Liquid::If::BOOLEAN_OPERATORS = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/tags/if.rb#42
Liquid::If::ELSE_TAG_NAMES = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/tags/if.rb#18
Liquid::If::ExpressionsAndOperators = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/if.rb#132
class Liquid::If::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/if.rb#133
  def children; end
end

# source://liquid//lib/liquid/tags/if.rb#17
Liquid::If::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/ifchanged.rb#4
class Liquid::Ifchanged < ::Liquid::Block
  # source://liquid//lib/liquid/tags/ifchanged.rb#5
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/tags/include.rb#20
class Liquid::Include < ::Liquid::Tag
  include ::Liquid::Tag::Disableable

  # @return [Include] a new instance of Include
  #
  # source://liquid//lib/liquid/tags/include.rb#28
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute attributes.
  #
  # source://liquid//lib/liquid/tags/include.rb#26
  def attributes; end

  # source://liquid//lib/liquid/tags/include.rb#50
  def parse(_tokens); end

  # @raise [ArgumentError]
  #
  # source://liquid//lib/liquid/tag/disableable.rb#6
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute template_name_expr.
  #
  # source://liquid//lib/liquid/tags/include.rb#26
  def template_name_expr; end

  # Returns the value of attribute variable_name_expr.
  #
  # source://liquid//lib/liquid/tags/include.rb#26
  def variable_name_expr; end

  private

  # source://liquid//lib/liquid/tag.rb#8
  def parse_context; end
end

# source://liquid//lib/liquid/tags/include.rb#104
class Liquid::Include::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/include.rb#105
  def children; end
end

# source://liquid//lib/liquid/tags/include.rb#23
Liquid::Include::SYNTAX = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/include.rb#24
Liquid::Include::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/increment.rb#21
class Liquid::Increment < ::Liquid::Tag
  # @return [Increment] a new instance of Increment
  #
  # source://liquid//lib/liquid/tags/increment.rb#24
  def initialize(tag_name, markup, options); end

  # source://liquid//lib/liquid/tags/increment.rb#29
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute variable_name.
  #
  # source://liquid//lib/liquid/tags/increment.rb#22
  def variable_name; end
end

# source://liquid//lib/liquid/tags/inline_comment.rb#4
class Liquid::InlineComment < ::Liquid::Tag
  # @return [InlineComment] a new instance of InlineComment
  #
  # source://liquid//lib/liquid/tags/inline_comment.rb#5
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/inline_comment.rb#24
  def blank?; end

  # source://liquid//lib/liquid/tags/inline_comment.rb#20
  def render_to_output_buffer(_context, output); end
end

# source://liquid//lib/liquid/errors.rb#57
class Liquid::InternalError < ::Liquid::Error; end

# An interrupt is any command that breaks processing of a block (ex: a for loop).
#
# source://liquid//lib/liquid/interrupts.rb#5
class Liquid::Interrupt
  # @return [Interrupt] a new instance of Interrupt
  #
  # source://liquid//lib/liquid/interrupts.rb#8
  def initialize(message = T.unsafe(nil)); end

  # Returns the value of attribute message.
  #
  # source://liquid//lib/liquid/interrupts.rb#6
  def message; end
end

# source://liquid//lib/liquid/lexer.rb#4
class Liquid::Lexer
  class << self
    # @raise [SyntaxError]
    #
    # source://liquid//lib/liquid/lexer.rb#172
    def raise_syntax_error(start_pos, ss); end

    # source://liquid//lib/liquid/lexer.rb#103
    def tokenize(ss); end
  end
end

# source://liquid//lib/liquid/lexer.rb#5
Liquid::Lexer::CLOSE_ROUND = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#6
Liquid::Lexer::CLOSE_SQUARE = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#7
Liquid::Lexer::COLON = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#8
Liquid::Lexer::COMMA = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#9
Liquid::Lexer::COMPARISION_NOT_EQUAL = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#10
Liquid::Lexer::COMPARISON_CONTAINS = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#11
Liquid::Lexer::COMPARISON_EQUAL = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#12
Liquid::Lexer::COMPARISON_GREATER_THAN = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#13
Liquid::Lexer::COMPARISON_GREATER_THAN_OR_EQUAL = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#51
Liquid::Lexer::COMPARISON_JUMP_TABLE = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#14
Liquid::Lexer::COMPARISON_LESS_THAN = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#15
Liquid::Lexer::COMPARISON_LESS_THAN_OR_EQUAL = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#16
Liquid::Lexer::COMPARISON_NOT_EQUAL_ALT = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#17
Liquid::Lexer::DASH = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#18
Liquid::Lexer::DOT = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#19
Liquid::Lexer::DOTDOT = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#20
Liquid::Lexer::DOT_ORD = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/lexer.rb#21
Liquid::Lexer::DOUBLE_STRING_LITERAL = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/lexer.rb#22
Liquid::Lexer::EOS = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#23
Liquid::Lexer::IDENTIFIER = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/lexer.rb#64
Liquid::Lexer::NEXT_MATCHER_JUMP_TABLE = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#24
Liquid::Lexer::NUMBER_LITERAL = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/lexer.rb#94
Liquid::Lexer::NUMBER_TABLE = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#25
Liquid::Lexer::OPEN_ROUND = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#26
Liquid::Lexer::OPEN_SQUARE = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#27
Liquid::Lexer::PIPE = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#28
Liquid::Lexer::QUESTION = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#29
Liquid::Lexer::RUBY_WHITESPACE = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#33
Liquid::Lexer::SINGLE_COMPARISON_TOKENS = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#30
Liquid::Lexer::SINGLE_STRING_LITERAL = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/lexer.rb#81
Liquid::Lexer::SPECIAL_TABLE = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#39
Liquid::Lexer::TWO_CHARS_COMPARISON_JUMP_TABLE = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/lexer.rb#31
Liquid::Lexer::WHITESPACE_OR_NOTHING = T.let(T.unsafe(nil), Regexp)

# This implements an abstract file system which retrieves template files named in a manner similar to Rails partials,
# ie. with the template name prefixed with an underscore. The extension ".liquid" is also added.
#
# For security reasons, template paths are only allowed to contain letters, numbers, and underscore.
#
# Example:
#
#   file_system = Liquid::LocalFileSystem.new("/some/path")
#
#   file_system.full_path("mypartial")       # => "/some/path/_mypartial.liquid"
#   file_system.full_path("dir/mypartial")   # => "/some/path/dir/_mypartial.liquid"
#
# Optionally in the second argument you can specify a custom pattern for template filenames.
# The Kernel::sprintf format specification is used.
# Default pattern is "_%s.liquid".
#
# Example:
#
#   file_system = Liquid::LocalFileSystem.new("/some/path", "%s.html")
#
#   file_system.full_path("index") # => "/some/path/index.html"
#
# source://liquid//lib/liquid/file_system.rb#46
class Liquid::LocalFileSystem
  # @return [LocalFileSystem] a new instance of LocalFileSystem
  #
  # source://liquid//lib/liquid/file_system.rb#49
  def initialize(root, pattern = T.unsafe(nil)); end

  # @raise [FileSystemError]
  #
  # source://liquid//lib/liquid/file_system.rb#61
  def full_path(template_path); end

  # @raise [FileSystemError]
  #
  # source://liquid//lib/liquid/file_system.rb#54
  def read_template_file(template_path); end

  # Returns the value of attribute root.
  #
  # source://liquid//lib/liquid/file_system.rb#47
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  #
  # source://liquid//lib/liquid/file_system.rb#47
  def root=(_arg0); end
end

# source://liquid//lib/liquid/errors.rb#49
class Liquid::MemoryError < ::Liquid::Error; end

# source://liquid//lib/liquid/errors.rb#55
class Liquid::MethodOverrideError < ::Liquid::Error; end

# source://liquid//lib/liquid/parse_context.rb#4
class Liquid::ParseContext
  # @return [ParseContext] a new instance of ParseContext
  #
  # source://liquid//lib/liquid/parse_context.rb#8
  def initialize(options = T.unsafe(nil)); end

  # source://liquid//lib/liquid/parse_context.rb#31
  def [](option_key); end

  # Returns the value of attribute depth.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def depth; end

  # Sets the attribute depth
  #
  # @param value the value to set the attribute depth to.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def depth=(_arg0); end

  # Returns the value of attribute environment.
  #
  # source://liquid//lib/liquid/parse_context.rb#6
  def environment; end

  # Returns the value of attribute error_mode.
  #
  # source://liquid//lib/liquid/parse_context.rb#6
  def error_mode; end

  # Returns the value of attribute line_number.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def line_number=(_arg0); end

  # Returns the value of attribute locale.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def locale; end

  # Sets the attribute locale
  #
  # @param value the value to set the attribute locale to.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def locale=(_arg0); end

  # source://liquid//lib/liquid/parse_context.rb#35
  def new_block_body; end

  # source://liquid//lib/liquid/parse_context.rb#39
  def new_parser(input); end

  # source://liquid//lib/liquid/parse_context.rb#44
  def new_tokenizer(source, start_line_number: T.unsafe(nil), for_liquid_tag: T.unsafe(nil)); end

  # source://liquid//lib/liquid/parse_context.rb#53
  def parse_expression(markup); end

  # Returns the value of attribute partial.
  #
  # source://liquid//lib/liquid/parse_context.rb#6
  def partial; end

  # source://liquid//lib/liquid/parse_context.rb#57
  def partial=(value); end

  # source://liquid//lib/liquid/parse_context.rb#64
  def partial_options; end

  # Returns the value of attribute trim_whitespace.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def trim_whitespace; end

  # Sets the attribute trim_whitespace
  #
  # @param value the value to set the attribute trim_whitespace to.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def trim_whitespace=(_arg0); end

  # Returns the value of attribute warnings.
  #
  # source://liquid//lib/liquid/parse_context.rb#6
  def warnings; end
end

# source://liquid//lib/liquid/parse_tree_visitor.rb#4
class Liquid::ParseTreeVisitor
  # @return [ParseTreeVisitor] a new instance of ParseTreeVisitor
  #
  # source://liquid//lib/liquid/parse_tree_visitor.rb#13
  def initialize(node, callbacks); end

  # source://liquid//lib/liquid/parse_tree_visitor.rb#18
  def add_callback_for(*classes, &block); end

  # source://liquid//lib/liquid/parse_tree_visitor.rb#26
  def visit(context = T.unsafe(nil)); end

  protected

  # source://liquid//lib/liquid/parse_tree_visitor.rb#38
  def children; end

  class << self
    # source://liquid//lib/liquid/parse_tree_visitor.rb#5
    def for(node, callbacks = T.unsafe(nil)); end
  end
end

# source://liquid//lib/liquid/parser.rb#4
class Liquid::Parser
  # @return [Parser] a new instance of Parser
  #
  # source://liquid//lib/liquid/parser.rb#5
  def initialize(input); end

  # source://liquid//lib/liquid/parser.rb#74
  def argument; end

  # source://liquid//lib/liquid/parser.rb#15
  def consume(type = T.unsafe(nil)); end

  # Only consumes the token if it matches the type
  # Returns the token's contents if it was consumed
  # or false otherwise.
  #
  # @return [Boolean]
  #
  # source://liquid//lib/liquid/parser.rb#27
  def consume?(type); end

  # source://liquid//lib/liquid/parser.rb#49
  def expression; end

  # Like consume? Except for an :id token of a certain name
  #
  # @return [Boolean]
  #
  # source://liquid//lib/liquid/parser.rb#35
  def id?(str); end

  # source://liquid//lib/liquid/parser.rb#11
  def jump(point); end

  # source://liquid//lib/liquid/parser.rb#43
  def look(type, ahead = T.unsafe(nil)); end

  # source://liquid//lib/liquid/parser.rb#85
  def variable_lookups; end
end

# source://liquid//lib/liquid/parser_switching.rb#4
module Liquid::ParserSwitching
  # source://liquid//lib/liquid/parser_switching.rb#17
  def parse_with_selected_parser(markup); end

  # source://liquid//lib/liquid/parser_switching.rb#5
  def strict_parse_with_error_mode_fallback(markup); end

  private

  # source://liquid//lib/liquid/parser_switching.rb#41
  def markup_context(markup); end

  # source://liquid//lib/liquid/parser_switching.rb#33
  def strict_parse_with_error_context(markup); end
end

# source://liquid//lib/liquid/partial_cache.rb#4
class Liquid::PartialCache
  class << self
    # source://liquid//lib/liquid/partial_cache.rb#5
    def load(template_name, context:, parse_context:); end
  end
end

# source://liquid//lib/liquid.rb#44
Liquid::PartialTemplateParser = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#41
Liquid::QuotedFragment = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#40
Liquid::QuotedString = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#48
Liquid::RAISE_EXCEPTION_LAMBDA = T.let(T.unsafe(nil), Proc)

# source://liquid//lib/liquid/range_lookup.rb#4
class Liquid::RangeLookup
  # @return [RangeLookup] a new instance of RangeLookup
  #
  # source://liquid//lib/liquid/range_lookup.rb#27
  def initialize(start_obj, end_obj); end

  # Returns the value of attribute end_obj.
  #
  # source://liquid//lib/liquid/range_lookup.rb#25
  def end_obj; end

  # source://liquid//lib/liquid/range_lookup.rb#32
  def evaluate(context); end

  # Returns the value of attribute start_obj.
  #
  # source://liquid//lib/liquid/range_lookup.rb#25
  def start_obj; end

  private

  # source://liquid//lib/liquid/range_lookup.rb#40
  def to_integer(input); end

  class << self
    # source://liquid//lib/liquid/range_lookup.rb#5
    def parse(start_markup, end_markup, string_scanner, cache = T.unsafe(nil)); end
  end
end

# source://liquid//lib/liquid/range_lookup.rb#51
class Liquid::RangeLookup::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/range_lookup.rb#52
  def children; end
end

# source://liquid//lib/liquid/tags/raw.rb#15
class Liquid::Raw < ::Liquid::Block
  # @return [Raw] a new instance of Raw
  #
  # source://liquid//lib/liquid/tags/raw.rb#18
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/raw.rb#47
  def blank?; end

  # source://liquid//lib/liquid/tags/raw.rb#43
  def nodelist; end

  # source://liquid//lib/liquid/tags/raw.rb#24
  def parse(tokens); end

  # source://liquid//lib/liquid/tags/raw.rb#38
  def render_to_output_buffer(_context, output); end

  protected

  # source://liquid//lib/liquid/tags/raw.rb#53
  def ensure_valid_markup(tag_name, markup, parse_context); end
end

# source://liquid//lib/liquid/tags/raw.rb#16
Liquid::Raw::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/registers.rb#4
class Liquid::Registers
  # @return [Registers] a new instance of Registers
  #
  # source://liquid//lib/liquid/registers.rb#7
  def initialize(registers = T.unsafe(nil)); end

  # source://liquid//lib/liquid/registers.rb#16
  def [](key); end

  # source://liquid//lib/liquid/registers.rb#12
  def []=(key, value); end

  # source://liquid//lib/liquid/registers.rb#24
  def delete(key); end

  # source://liquid//lib/liquid/registers.rb#30
  def fetch(key, default = T.unsafe(nil), &block); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/registers.rb#44
  def key?(key); end

  # Returns the value of attribute static.
  #
  # source://liquid//lib/liquid/registers.rb#5
  def static; end
end

# source://liquid//lib/liquid/registers.rb#28
Liquid::Registers::UNDEFINED = T.let(T.unsafe(nil), Object)

# source://liquid//lib/liquid/tags/render.rb#28
class Liquid::Render < ::Liquid::Tag
  include ::Liquid::Tag::Disabler

  # @raise [SyntaxError]
  # @return [Render] a new instance of Render
  #
  # source://liquid//lib/liquid/tags/render.rb#36
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute alias_name.
  #
  # source://liquid//lib/liquid/tags/render.rb#34
  def alias_name; end

  # Returns the value of attribute attributes.
  #
  # source://liquid//lib/liquid/tags/render.rb#34
  def attributes; end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/render.rb#56
  def for_loop?; end

  # @raise [::ArgumentError]
  #
  # source://liquid//lib/liquid/tags/render.rb#64
  def render_tag(context, output); end

  # source://liquid//lib/liquid/tag/disabler.rb#6
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute template_name_expr.
  #
  # source://liquid//lib/liquid/tags/render.rb#34
  def template_name_expr; end

  # Returns the value of attribute variable_name_expr.
  #
  # source://liquid//lib/liquid/tags/render.rb#34
  def variable_name_expr; end

  class << self
    # source://liquid//lib/liquid/tag.rb#21
    def disabled_tags; end
  end
end

# source://liquid//lib/liquid/tags/render.rb#29
Liquid::Render::FOR = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid/tags/render.rb#102
class Liquid::Render::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/render.rb#103
  def children; end
end

# source://liquid//lib/liquid/tags/render.rb#30
Liquid::Render::SYNTAX = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/resource_limits.rb#4
class Liquid::ResourceLimits
  # @return [ResourceLimits] a new instance of ResourceLimits
  #
  # source://liquid//lib/liquid/resource_limits.rb#8
  def initialize(limits); end

  # Returns the value of attribute assign_score.
  #
  # source://liquid//lib/liquid/resource_limits.rb#6
  def assign_score; end

  # Returns the value of attribute assign_score_limit.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def assign_score_limit; end

  # Sets the attribute assign_score_limit
  #
  # @param value the value to set the attribute assign_score_limit to.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def assign_score_limit=(_arg0); end

  # source://liquid//lib/liquid/resource_limits.rb#20
  def increment_assign_score(amount); end

  # source://liquid//lib/liquid/resource_limits.rb#15
  def increment_render_score(amount); end

  # update either render_length or assign_score based on whether or not the writes are captured
  #
  # source://liquid//lib/liquid/resource_limits.rb#26
  def increment_write_score(output); end

  # @raise [MemoryError]
  #
  # source://liquid//lib/liquid/resource_limits.rb#37
  def raise_limits_reached; end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/resource_limits.rb#42
  def reached?; end

  # Returns the value of attribute render_length_limit.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def render_length_limit; end

  # Sets the attribute render_length_limit
  #
  # @param value the value to set the attribute render_length_limit to.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def render_length_limit=(_arg0); end

  # Returns the value of attribute render_score.
  #
  # source://liquid//lib/liquid/resource_limits.rb#6
  def render_score; end

  # Returns the value of attribute render_score_limit.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def render_score_limit; end

  # Sets the attribute render_score_limit
  #
  # @param value the value to set the attribute render_score_limit to.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def render_score_limit=(_arg0); end

  # source://liquid//lib/liquid/resource_limits.rb#46
  def reset; end

  # source://liquid//lib/liquid/resource_limits.rb#52
  def with_capture; end
end

# source://liquid//lib/liquid/errors.rb#48
class Liquid::StackLevelError < ::Liquid::Error; end

# source://liquid//lib/liquid/errors.rb#46
class Liquid::StandardError < ::Liquid::Error; end

# source://liquid//lib/liquid/standardfilters.rb#7
module Liquid::StandardFilters
  # source://liquid//lib/liquid/standardfilters.rb#792
  def abs(input); end

  # source://liquid//lib/liquid/standardfilters.rb#665
  def append(input, string); end

  # source://liquid//lib/liquid/standardfilters.rb#905
  def at_least(input, n); end

  # source://liquid//lib/liquid/standardfilters.rb#920
  def at_most(input, n); end

  # source://liquid//lib/liquid/standardfilters.rb#164
  def base64_decode(input); end

  # source://liquid//lib/liquid/standardfilters.rb#153
  def base64_encode(input); end

  # source://liquid//lib/liquid/standardfilters.rb#189
  def base64_url_safe_decode(input); end

  # source://liquid//lib/liquid/standardfilters.rb#178
  def base64_url_safe_encode(input); end

  # source://liquid//lib/liquid/standardfilters.rb#87
  def capitalize(input); end

  # source://liquid//lib/liquid/standardfilters.rb#879
  def ceil(input); end

  # source://liquid//lib/liquid/standardfilters.rb#557
  def compact(input, property = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#682
  def concat(input, array); end

  # source://liquid//lib/liquid/standardfilters.rb#754
  def date(input, format); end

  # source://liquid//lib/liquid/standardfilters.rb#940
  def default(input, default_value = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#837
  def divided_by(input, operand); end

  # source://liquid//lib/liquid/standardfilters.rb#65
  def downcase(input); end

  # source://liquid//lib/liquid/standardfilters.rb#98
  def escape(input); end

  # source://liquid//lib/liquid/standardfilters.rb#110
  def escape_once(input); end

  # source://liquid//lib/liquid/standardfilters.rb#473
  def find(input, property, target_value = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#486
  def find_index(input, property, target_value = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#770
  def first(array); end

  # source://liquid//lib/liquid/standardfilters.rb#892
  def floor(input); end

  # source://liquid//lib/liquid/standardfilters.rb#98
  def h(input); end

  # source://liquid//lib/liquid/standardfilters.rb#460
  def has(input, property, target_value = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#366
  def join(input, glue = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#781
  def last(array); end

  # source://liquid//lib/liquid/standardfilters.rb#315
  def lstrip(input); end

  # source://liquid//lib/liquid/standardfilters.rb#535
  def map(input, property); end

  # source://liquid//lib/liquid/standardfilters.rb#815
  def minus(input, operand); end

  # source://liquid//lib/liquid/standardfilters.rb#850
  def modulo(input, operand); end

  # source://liquid//lib/liquid/standardfilters.rb#709
  def newline_to_br(input); end

  # source://liquid//lib/liquid/standardfilters.rb#804
  def plus(input, operand); end

  # source://liquid//lib/liquid/standardfilters.rb#696
  def prepend(input, string); end

  # source://liquid//lib/liquid/standardfilters.rb#447
  def reject(input, property, target_value = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#632
  def remove(input, string); end

  # source://liquid//lib/liquid/standardfilters.rb#643
  def remove_first(input, string); end

  # source://liquid//lib/liquid/standardfilters.rb#654
  def remove_last(input, string); end

  # source://liquid//lib/liquid/standardfilters.rb#583
  def replace(input, string, replacement = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#597
  def replace_first(input, string, replacement = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#611
  def replace_last(input, string, replacement); end

  # source://liquid//lib/liquid/standardfilters.rb#523
  def reverse(input); end

  # source://liquid//lib/liquid/standardfilters.rb#863
  def round(input, n = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#327
  def rstrip(input); end

  # source://liquid//lib/liquid/standardfilters.rb#54
  def size(input); end

  # source://liquid//lib/liquid/standardfilters.rb#206
  def slice(input, offset, length = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#378
  def sort(input, property = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#407
  def sort_natural(input, property = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#290
  def split(input, pattern); end

  # source://liquid//lib/liquid/standardfilters.rb#303
  def strip(input); end

  # source://liquid//lib/liquid/standardfilters.rb#339
  def strip_html(input); end

  # source://liquid//lib/liquid/standardfilters.rb#354
  def strip_newlines(input); end

  # source://liquid//lib/liquid/standardfilters.rb#953
  def sum(input, property = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#826
  def times(input, operand); end

  # source://liquid//lib/liquid/standardfilters.rb#236
  def truncate(input, length = T.unsafe(nil), truncate_string = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#263
  def truncatewords(input, words = T.unsafe(nil), truncate_string = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#497
  def uniq(input, property = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#76
  def upcase(input); end

  # @raise [Liquid::ArgumentError]
  #
  # source://liquid//lib/liquid/standardfilters.rb#137
  def url_decode(input); end

  # source://liquid//lib/liquid/standardfilters.rb#125
  def url_encode(input); end

  # source://liquid//lib/liquid/standardfilters.rb#434
  def where(input, property, target_value = T.unsafe(nil)); end

  private

  # source://liquid//lib/liquid/standardfilters.rb#1003
  def apply_operation(input, operand, operation); end

  # Returns the value of attribute context.
  #
  # source://liquid//lib/liquid/standardfilters.rb#978
  def context; end

  # source://liquid//lib/liquid/standardfilters.rb#980
  def filter_array(input, property, target_value, default_value = T.unsafe(nil), &block); end

  # source://liquid//lib/liquid/standardfilters.rb#1022
  def nil_safe_casecmp(a, b); end

  # source://liquid//lib/liquid/standardfilters.rb#1008
  def nil_safe_compare(a, b); end

  # @raise [Liquid::ArgumentError]
  #
  # source://liquid//lib/liquid/standardfilters.rb#999
  def raise_property_error(property); end

  class << self
    # source://liquid//lib/liquid/standardfilters.rb#32
    def try_coerce_encoding(input, encoding:); end
  end
end

# source://liquid//lib/liquid/standardfilters.rb#16
Liquid::StandardFilters::HTML_ESCAPE = T.let(T.unsafe(nil), Hash)

# source://liquid//lib/liquid/standardfilters.rb#23
Liquid::StandardFilters::HTML_ESCAPE_ONCE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/standardfilters.rb#13
Liquid::StandardFilters::I64_RANGE = T.let(T.unsafe(nil), Range)

# source://liquid//lib/liquid/standardfilters.rb#1032
class Liquid::StandardFilters::InputIterator
  include ::Enumerable

  # @return [InputIterator] a new instance of InputIterator
  #
  # source://liquid//lib/liquid/standardfilters.rb#1035
  def initialize(input, context); end

  # source://liquid//lib/liquid/standardfilters.rb#1078
  def compact; end

  # source://liquid//lib/liquid/standardfilters.rb#1063
  def concat(args); end

  # source://liquid//lib/liquid/standardfilters.rb#1087
  def each; end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/standardfilters.rb#1082
  def empty?; end

  # source://liquid//lib/liquid/standardfilters.rb#1048
  def join(glue); end

  # source://liquid//lib/liquid/standardfilters.rb#1067
  def reverse; end

  # source://liquid//lib/liquid/standardfilters.rb#1071
  def uniq(&block); end
end

# source://liquid//lib/liquid/standardfilters.rb#8
Liquid::StandardFilters::MAX_I32 = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/standardfilters.rb#12
Liquid::StandardFilters::MAX_I64 = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/standardfilters.rb#11
Liquid::StandardFilters::MIN_I64 = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/standardfilters.rb#24
Liquid::StandardFilters::STRIP_HTML_BLOCKS = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/standardfilters.rb#29
Liquid::StandardFilters::STRIP_HTML_TAGS = T.let(T.unsafe(nil), Regexp)

# Alias for backwards compatibility
#
# source://liquid//lib/liquid/registers.rb#50
Liquid::StaticRegisters = Liquid::Registers

# StrainerTemplate is the computed class for the filters system.
# New filters are mixed into the strainer class which is then instantiated for each liquid template render run.
#
# The Strainer only allows method calls defined in filters given to it via StrainerFactory.add_global_filter,
# Context#add_filters or Template.register_filter
#
# source://liquid//lib/liquid/strainer_template.rb#11
class Liquid::StrainerTemplate
  # @return [StrainerTemplate] a new instance of StrainerTemplate
  #
  # source://liquid//lib/liquid/strainer_template.rb#12
  def initialize(context); end

  # source://liquid//lib/liquid/strainer_template.rb#50
  def invoke(method, *args); end

  class << self
    # source://liquid//lib/liquid/strainer_template.rb#17
    def add_filter(filter); end

    # source://liquid//lib/liquid/strainer_template.rb#39
    def filter_method_names; end

    # @private
    #
    # source://liquid//lib/liquid/strainer_template.rb#34
    def inherited(subclass); end

    # @return [Boolean]
    #
    # source://liquid//lib/liquid/strainer_template.rb#30
    def invokable?(method); end

    private

    # source://liquid//lib/liquid/strainer_template.rb#45
    def filter_methods; end
  end
end

# source://liquid//lib/liquid/errors.rb#47
class Liquid::SyntaxError < ::Liquid::Error; end

# source://liquid//lib/liquid/tags/table_row.rb#26
class Liquid::TableRow < ::Liquid::Block
  # @return [TableRow] a new instance of TableRow
  #
  # source://liquid//lib/liquid/tags/table_row.rb#31
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute attributes.
  #
  # source://liquid//lib/liquid/tags/table_row.rb#29
  def attributes; end

  # Returns the value of attribute collection_name.
  #
  # source://liquid//lib/liquid/tags/table_row.rb#29
  def collection_name; end

  # source://liquid//lib/liquid/tags/table_row.rb#45
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute variable_name.
  #
  # source://liquid//lib/liquid/tags/table_row.rb#29
  def variable_name; end

  private

  # source://liquid//lib/liquid/tags/table_row.rb#94
  def to_integer(value); end
end

# source://liquid//lib/liquid/tags/table_row.rb#86
class Liquid::TableRow::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/table_row.rb#87
  def children; end
end

# source://liquid//lib/liquid/tags/table_row.rb#27
Liquid::TableRow::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tablerowloop_drop.rb#9
class Liquid::TablerowloopDrop < ::Liquid::Drop
  # @return [TablerowloopDrop] a new instance of TablerowloopDrop
  #
  # source://liquid//lib/liquid/tablerowloop_drop.rb#10
  def initialize(length, cols); end

  # Returns the value of attribute col.
  #
  # source://liquid//lib/liquid/tablerowloop_drop.rb#28
  def col; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#56
  def col0; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#96
  def col_first; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#104
  def col_last; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#80
  def first; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#40
  def index; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#48
  def index0; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#88
  def last; end

  # Returns the value of attribute length.
  #
  # source://liquid//lib/liquid/tablerowloop_drop.rb#22
  def length; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#64
  def rindex; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#72
  def rindex0; end

  # Returns the value of attribute row.
  #
  # source://liquid//lib/liquid/tablerowloop_drop.rb#34
  def row; end

  protected

  # source://liquid//lib/liquid/tablerowloop_drop.rb#110
  def increment!; end
end

# source://liquid//lib/liquid/tag/disabler.rb#4
class Liquid::Tag
  include ::Liquid::ParserSwitching

  # @return [Tag] a new instance of Tag
  #
  # source://liquid//lib/liquid/tag.rb#34
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tag.rb#65
  def blank?; end

  # Returns the value of attribute line_number.
  #
  # source://liquid//lib/liquid/tag.rb#8
  def line_number; end

  # source://liquid//lib/liquid/tag.rb#48
  def name; end

  # Returns the value of attribute nodelist.
  #
  # source://liquid//lib/liquid/tag.rb#8
  def nodelist; end

  # Returns the value of attribute parse_context.
  #
  # source://liquid//lib/liquid/tag.rb#8
  def options; end

  # source://liquid//lib/liquid/tag.rb#41
  def parse(_tokens); end

  # Returns the value of attribute parse_context.
  #
  # source://liquid//lib/liquid/tag.rb#8
  def parse_context; end

  # source://liquid//lib/liquid/tag.rb#44
  def raw; end

  # source://liquid//lib/liquid/tag.rb#52
  def render(_context); end

  # For backwards compatibility with custom tags. In a future release, the semantics
  # of the `render_to_output_buffer` method will become the default and the `render`
  # method will be removed.
  #
  # source://liquid//lib/liquid/tag.rb#59
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute tag_name.
  #
  # source://liquid//lib/liquid/tag.rb#8
  def tag_name; end

  private

  # source://liquid//lib/liquid/tag.rb#71
  def parse_expression(markup); end

  class << self
    # source://liquid//lib/liquid/tag.rb#19
    def disable_tags(*tag_names); end

    # source://liquid//lib/liquid/tag.rb#13
    def parse(tag_name, markup, tokenizer, parse_context); end

    protected

    # source://liquid//lib/liquid/tag.rb#29
    def disabled_tags; end

    private

    def new(*_arg0); end
  end
end

# source://liquid//lib/liquid/tag/disableable.rb#5
module Liquid::Tag::Disableable
  # source://liquid//lib/liquid/tag/disableable.rb#14
  def disabled_error(context); end

  # source://liquid//lib/liquid/tag/disableable.rb#6
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/tag/disabler.rb#5
module Liquid::Tag::Disabler
  # source://liquid//lib/liquid/tag/disabler.rb#6
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid.rb#42
Liquid::TagAttributes = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#33
Liquid::TagEnd = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#34
Liquid::TagName = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#32
Liquid::TagStart = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags.rb#25
module Liquid::Tags; end

# source://liquid//lib/liquid/tags.rb#26
Liquid::Tags::STANDARD_TAGS = T.let(T.unsafe(nil), Hash)

# Templates are central to liquid.
# Interpretating templates is a two step process. First you compile the
# source code you got. During compile time some extensive error checking is performed.
# your code should expect to get some SyntaxErrors.
#
# After you have a compiled template you can then <tt>render</tt> it.
# You can use a compiled template over and over again and keep it cached.
#
# Example:
#
#   template = Liquid::Template.parse(source)
#   template.render('user_name' => 'bob')
#
# source://liquid//lib/liquid/template.rb#17
class Liquid::Template
  # @return [Template] a new instance of Template
  #
  # source://liquid//lib/liquid/template.rb#89
  def initialize(environment: T.unsafe(nil)); end

  # source://liquid//lib/liquid/template.rb#114
  def assigns; end

  # source://liquid//lib/liquid/template.rb#122
  def errors; end

  # source://liquid//lib/liquid/template.rb#118
  def instance_assigns; end

  # Returns the value of attribute name.
  #
  # source://liquid//lib/liquid/template.rb#18
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://liquid//lib/liquid/template.rb#18
  def name=(_arg0); end

  # Parse source code.
  # Returns self for easy chaining
  #
  # source://liquid//lib/liquid/template.rb#97
  def parse(source, options = T.unsafe(nil)); end

  # Returns the value of attribute profiler.
  #
  # source://liquid//lib/liquid/template.rb#21
  def profiler; end

  # source://liquid//lib/liquid/template.rb#110
  def registers; end

  # Render takes a hash with local variables.
  #
  # if you use the same filters over and over again consider registering them globally
  # with <tt>Template.register_filter</tt>
  #
  # if profiling was enabled in <tt>Template#parse</tt> then the resulting profiling information
  # will be available via <tt>Template#profiler</tt>
  #
  # Following options can be passed:
  #
  #  * <tt>filters</tt> : array with local filters
  #  * <tt>registers</tt> : hash with register variables. Those can be accessed from
  #    filters and tags and might be useful to integrate liquid more with its host application
  #
  # source://liquid//lib/liquid/template.rb#140
  def render(*args); end

  # source://liquid//lib/liquid/template.rb#199
  def render!(*args); end

  # source://liquid//lib/liquid/template.rb#204
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute resource_limits.
  #
  # source://liquid//lib/liquid/template.rb#19
  def resource_limits; end

  # Returns the value of attribute root.
  #
  # source://liquid//lib/liquid/template.rb#18
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  #
  # source://liquid//lib/liquid/template.rb#18
  def root=(_arg0); end

  # Returns the value of attribute warnings.
  #
  # source://liquid//lib/liquid/template.rb#19
  def warnings; end

  private

  # source://liquid//lib/liquid/template.rb#229
  def apply_options_to_context(context, options); end

  # source://liquid//lib/liquid/template.rb#210
  def configure_options(options); end

  class << self
    # source://liquid//lib/liquid/template.rb#42
    def default_exception_renderer; end

    # source://liquid//lib/liquid/template.rb#37
    def default_exception_renderer=(renderer); end

    # source://liquid//lib/liquid/template.rb#76
    def default_resource_limits; end

    # source://liquid//lib/liquid/template.rb#33
    def error_mode; end

    # Sets how strict the parser should be.
    # :lax acts like liquid 2.5 and silently ignores malformed tags in most cases.
    # :warn is the default and will give deprecation warnings when invalid syntax is used.
    # :strict will enforce correct syntax.
    #
    # source://liquid//lib/liquid/template.rb#28
    def error_mode=(mode); end

    # source://liquid//lib/liquid/template.rb#51
    def file_system; end

    # source://liquid//lib/liquid/template.rb#46
    def file_system=(file_system); end

    # creates a new <tt>Template</tt> object from liquid source code
    # To enable profiling, pass in <tt>profile: true</tt> as an option.
    # See Liquid::Profiler for more information
    #
    # source://liquid//lib/liquid/template.rb#83
    def parse(source, options = T.unsafe(nil)); end

    # Pass a module with filter methods which should be available
    # to all liquid views. Good for registering the standard library
    #
    # source://liquid//lib/liquid/template.rb#66
    def register_filter(mod); end

    # source://liquid//lib/liquid/template.rb#59
    def register_tag(name, klass); end

    # source://liquid//lib/liquid/template.rb#55
    def tags; end

    private

    # source://liquid//lib/liquid/template.rb#71
    def default_resource_limits=(limits); end
  end
end

# source://liquid//lib/liquid/errors.rb#58
class Liquid::TemplateEncodingError < ::Liquid::Error; end

# source://liquid//lib/liquid/template_factory.rb#4
class Liquid::TemplateFactory
  # source://liquid//lib/liquid/template_factory.rb#5
  def for(_template_name); end
end

# source://liquid//lib/liquid.rb#45
Liquid::TemplateParser = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tokenizer.rb#6
class Liquid::Tokenizer
  # @return [Tokenizer] a new instance of Tokenizer
  #
  # source://liquid//lib/liquid/tokenizer.rb#17
  def initialize(source:, string_scanner:, line_numbers: T.unsafe(nil), line_number: T.unsafe(nil), for_liquid_tag: T.unsafe(nil)); end

  # Returns the value of attribute for_liquid_tag.
  #
  # source://liquid//lib/liquid/tokenizer.rb#7
  def for_liquid_tag; end

  # Returns the value of attribute line_number.
  #
  # source://liquid//lib/liquid/tokenizer.rb#7
  def line_number; end

  # source://liquid//lib/liquid/tokenizer.rb#37
  def shift; end

  private

  # source://liquid//lib/liquid/tokenizer.rb#147
  def next_tag_token; end

  # source://liquid//lib/liquid/tokenizer.rb#156
  def next_tag_token_with_start(start); end

  # source://liquid//lib/liquid/tokenizer.rb#95
  def next_text_token; end

  # source://liquid//lib/liquid/tokenizer.rb#72
  def next_token; end

  # source://liquid//lib/liquid/tokenizer.rb#114
  def next_variable_token; end

  # source://liquid//lib/liquid/tokenizer.rb#64
  def shift_normal; end

  # source://liquid//lib/liquid/tokenizer.rb#53
  def tokenize; end
end

# source://liquid//lib/liquid/tokenizer.rb#14
Liquid::Tokenizer::CLOSE_CURLEY = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/tokenizer.rb#11
Liquid::Tokenizer::NEWLINE = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tokenizer.rb#13
Liquid::Tokenizer::OPEN_CURLEY = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/tokenizer.rb#15
Liquid::Tokenizer::PERCENTAGE = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/tokenizer.rb#9
Liquid::Tokenizer::TAG_END = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tokenizer.rb#10
Liquid::Tokenizer::TAG_OR_VARIABLE_START = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/errors.rb#53
class Liquid::UndefinedDropMethod < ::Liquid::Error; end

# source://liquid//lib/liquid/errors.rb#54
class Liquid::UndefinedFilter < ::Liquid::Error; end

# source://liquid//lib/liquid/errors.rb#52
class Liquid::UndefinedVariable < ::Liquid::Error; end

# source://liquid//lib/liquid/tags/unless.rb#21
class Liquid::Unless < ::Liquid::If
  # source://liquid//lib/liquid/tags/unless.rb#22
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/usage.rb#4
module Liquid::Usage
  class << self
    # source://liquid//lib/liquid/usage.rb#5
    def increment(name); end
  end
end

# source://liquid//lib/liquid/utils.rb#4
module Liquid::Utils
  class << self
    # source://liquid//lib/liquid/utils.rb#129
    def array_inspect(arr, seen = T.unsafe(nil)); end

    # source://liquid//lib/liquid/utils.rb#155
    def hash_inspect(hash, seen = T.unsafe(nil)); end

    # source://liquid//lib/liquid/utils.rb#111
    def inspect(obj, seen = T.unsafe(nil)); end

    # source://liquid//lib/liquid/utils.rb#5
    def slice_collection(collection, from, to); end

    # source://liquid//lib/liquid/utils.rb#13
    def slice_collection_using_each(collection, from, to); end

    # source://liquid//lib/liquid/utils.rb#65
    def to_date(obj); end

    # source://liquid//lib/liquid/utils.rb#38
    def to_integer(num); end

    # source://liquid//lib/liquid/utils.rb#85
    def to_liquid_value(obj); end

    # source://liquid//lib/liquid/utils.rb#48
    def to_number(obj); end

    # source://liquid//lib/liquid/utils.rb#93
    def to_s(obj, seen = T.unsafe(nil)); end
  end
end

# source://liquid//lib/liquid/utils.rb#186
Liquid::Utils::HASH_INSPECT_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# source://liquid//lib/liquid/utils.rb#183
Liquid::Utils::HASH_TO_S_METHOD = T.let(T.unsafe(nil), UnboundMethod)

# source://liquid//lib/liquid/version.rb#5
Liquid::VERSION = T.let(T.unsafe(nil), String)

# Holds variables. Variables are only loaded "just in time"
# and are not evaluated as part of the render stage
#
#   {{ monkey }}
#   {{ user.name }}
#
# Variables can be combined with filters:
#
#   {{ user | link }}
#
# source://liquid//lib/liquid/variable.rb#14
class Liquid::Variable
  include ::Liquid::ParserSwitching

  # @return [Variable] a new instance of Variable
  #
  # source://liquid//lib/liquid/variable.rb#27
  def initialize(markup, parse_context); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/variable.rb#115
  def disabled?(_context); end

  # source://liquid//lib/liquid/variable.rb#119
  def disabled_tags; end

  # Returns the value of attribute filters.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def filters; end

  # Sets the attribute filters
  #
  # @param value the value to set the attribute filters to.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def filters=(_arg0); end

  # source://liquid//lib/liquid/variable.rb#44
  def lax_parse(markup); end

  # Returns the value of attribute line_number.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def line_number=(_arg0); end

  # source://liquid//lib/liquid/variable.rb#40
  def markup_context(markup); end

  # Returns the value of attribute name.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def name=(_arg0); end

  # Returns the value of attribute parse_context.
  #
  # source://liquid//lib/liquid/variable.rb#22
  def options; end

  # Returns the value of attribute parse_context.
  #
  # source://liquid//lib/liquid/variable.rb#22
  def parse_context; end

  # source://liquid//lib/liquid/variable.rb#77
  def parse_filterargs(p); end

  # source://liquid//lib/liquid/variable.rb#36
  def raw; end

  # source://liquid//lib/liquid/variable.rb#85
  def render(context); end

  # source://liquid//lib/liquid/variable.rb#102
  def render_obj_to_output(obj, output); end

  # source://liquid//lib/liquid/variable.rb#96
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/variable.rb#62
  def strict_parse(markup); end

  private

  # source://liquid//lib/liquid/variable.rb#141
  def evaluate_filter_expressions(context, filter_args, filter_kwargs); end

  # source://liquid//lib/liquid/variable.rb#125
  def parse_filter_expressions(filter_name, unparsed_args); end
end

# source://liquid//lib/liquid/variable.rb#17
Liquid::Variable::FilterArgsRegex = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable.rb#15
Liquid::Variable::FilterMarkupRegex = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable.rb#16
Liquid::Variable::FilterParser = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable.rb#18
Liquid::Variable::JustTagAttributes = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable.rb#19
Liquid::Variable::MarkupWithQuotedFragment = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable.rb#153
class Liquid::Variable::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/variable.rb#154
  def children; end
end

# source://liquid//lib/liquid.rb#30
Liquid::VariableAttributeSeparator = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid.rb#38
Liquid::VariableEnd = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#39
Liquid::VariableIncompleteEnd = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable_lookup.rb#4
class Liquid::VariableLookup
  # @return [VariableLookup] a new instance of VariableLookup
  #
  # source://liquid//lib/liquid/variable_lookup.rb#13
  def initialize(markup, string_scanner = T.unsafe(nil), cache = T.unsafe(nil)); end

  # source://liquid//lib/liquid/variable_lookup.rb#88
  def ==(other); end

  # source://liquid//lib/liquid/variable_lookup.rb#47
  def evaluate(context); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/variable_lookup.rb#43
  def lookup_command?(lookup_index); end

  # Returns the value of attribute lookups.
  #
  # source://liquid//lib/liquid/variable_lookup.rb#7
  def lookups; end

  # Returns the value of attribute name.
  #
  # source://liquid//lib/liquid/variable_lookup.rb#7
  def name; end

  protected

  # source://liquid//lib/liquid/variable_lookup.rb#94
  def state; end

  class << self
    # source://liquid//lib/liquid/variable_lookup.rb#9
    def parse(markup, string_scanner = T.unsafe(nil), cache = T.unsafe(nil)); end
  end
end

# source://liquid//lib/liquid/variable_lookup.rb#5
Liquid::VariableLookup::COMMAND_METHODS = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/variable_lookup.rb#98
class Liquid::VariableLookup::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/variable_lookup.rb#99
  def children; end
end

# source://liquid//lib/liquid.rb#46
Liquid::VariableParser = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#36
Liquid::VariableSegment = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#35
Liquid::VariableSignature = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#37
Liquid::VariableStart = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#31
Liquid::WhitespaceControl = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid/errors.rb#50
class Liquid::ZeroDivisionError < ::Liquid::Error; end

# source://liquid//lib/liquid/extensions.rb#72
class NilClass
  # source://liquid//lib/liquid/extensions.rb#73
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#30
class Numeric
  include ::Comparable

  # source://liquid//lib/liquid/extensions.rb#31
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#36
class Range
  include ::Enumerable

  # source://liquid//lib/liquid/extensions.rb#37
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#6
class String
  include ::Comparable

  # source://liquid//lib/liquid/extensions.rb#7
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#12
class Symbol
  include ::Comparable

  # source://liquid//lib/liquid/extensions.rb#13
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#42
class Time
  include ::Comparable

  # source://liquid//lib/liquid/extensions.rb#43
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#60
class TrueClass
  # source://liquid//lib/liquid/extensions.rb#61
  def to_liquid; end
end
